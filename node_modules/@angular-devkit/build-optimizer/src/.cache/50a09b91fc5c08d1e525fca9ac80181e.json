{"remainingRequest":"/home/rahul/Desktop/svgcomplete/svg/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/rahul/Desktop/svgcomplete/svg/node_modules/@angular-redux/store/lib/src/decorators/helpers.js","dependencies":[{"path":"/home/rahul/Desktop/svgcomplete/svg/node_modules/@angular-redux/store/lib/src/decorators/helpers.js","mtime":1527648735000},{"path":"/home/rahul/Desktop/svgcomplete/svg/node_modules/cache-loader/dist/cjs.js","mtime":1529912799520},{"path":"/home/rahul/Desktop/svgcomplete/svg/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ng_redux_1 = require(\"../components/ng-redux\");\nvar operators_1 = require(\"rxjs/operators\");\n/**\n * OPTIONS_KEY: this is per-class (static) and holds the config from the\n * @SubStore decorator.\n */\nvar OPTIONS_KEY = '@angular-redux::substore::class::options';\n/**\n * INSTANCE_SUBSTORE_KEY, INSTANCE_SELECTIONS_KEY: these are per-instance\n * (non-static) and holds references to the substores/selected observables\n * to be used by an instance of a decorated class. I'm not using\n * reflect-metadata here because I want\n *\n * 1. different instances to have different substores in the case where\n * `basePathMethodName` is dynamic.\n * 2. the instance substore to be garbage collected when the instance is no\n * longer reachable.\n * This is therefore an own-property on the actual instance of the decorated\n * class.\n */\nvar INSTANCE_SUBSTORE_KEY = '@angular-redux::substore::instance::store';\nvar INSTANCE_SELECTIONS_KEY = '@angular-redux::substore::instance::selections';\n/**\n * Used to detect when the base path changes - this allows components to\n * dynamically adjust their selections if necessary.\n */\nvar INSTANCE_BASE_PATH_KEY = '@angular-redux::substore::instance::basepath';\nvar getClassOptions = function (decoratedInstance) {\n    return decoratedInstance.constructor[OPTIONS_KEY];\n};\nvar ɵ0 = getClassOptions;\nexports.ɵ0 = ɵ0;\n/** @hidden */\nexports.setClassOptions = function (decoratedClassConstructor, options) {\n    decoratedClassConstructor[OPTIONS_KEY] = options;\n};\n// I want the store to be saved on the actual instance so\n// 1. different instances can have distinct substores if necessary\n// 2. the substore/selections will be marked for garbage collection when the\n//    instance is destroyed.\nvar setInstanceStore = function (decoratedInstance, store) { return (decoratedInstance[INSTANCE_SUBSTORE_KEY] = store); };\nvar ɵ1 = setInstanceStore;\nexports.ɵ1 = ɵ1;\nvar getInstanceStore = function (decoratedInstance) {\n    return decoratedInstance[INSTANCE_SUBSTORE_KEY];\n};\nvar ɵ2 = getInstanceStore;\nexports.ɵ2 = ɵ2;\nvar getInstanceSelectionMap = function (decoratedInstance) {\n    var map = decoratedInstance[INSTANCE_SELECTIONS_KEY] || {};\n    decoratedInstance[INSTANCE_SELECTIONS_KEY] = map;\n    return map;\n};\nvar ɵ3 = getInstanceSelectionMap;\nexports.ɵ3 = ɵ3;\nvar hasBasePathChanged = function (decoratedInstance, basePath) {\n    return decoratedInstance[INSTANCE_BASE_PATH_KEY] !== (basePath || []).toString();\n};\nvar ɵ4 = hasBasePathChanged;\nexports.ɵ4 = ɵ4;\nvar setInstanceBasePath = function (decoratedInstance, basePath) {\n    decoratedInstance[INSTANCE_BASE_PATH_KEY] = (basePath || []).toString();\n};\nvar ɵ5 = setInstanceBasePath;\nexports.ɵ5 = ɵ5;\nvar clearInstanceState = function (decoratedInstance) {\n    decoratedInstance[INSTANCE_SELECTIONS_KEY] = null;\n    decoratedInstance[INSTANCE_SUBSTORE_KEY] = null;\n    decoratedInstance[INSTANCE_BASE_PATH_KEY] = null;\n};\nvar ɵ6 = clearInstanceState;\nexports.ɵ6 = ɵ6;\n/**\n * Gets the store associated with a decorated instance (e.g. a\n * component or service)\n * @hidden\n */\nexports.getBaseStore = function (decoratedInstance) {\n    // The root store hasn't been set up yet.\n    if (!ng_redux_1.NgRedux.instance) {\n        return undefined;\n    }\n    var options = getClassOptions(decoratedInstance);\n    // This is not decorated with `@WithSubStore`. Return the root store.\n    if (!options) {\n        return ng_redux_1.NgRedux.instance;\n    }\n    // Dynamic base path support:\n    var basePath = decoratedInstance[options.basePathMethodName]();\n    if (hasBasePathChanged(decoratedInstance, basePath)) {\n        clearInstanceState(decoratedInstance);\n        setInstanceBasePath(decoratedInstance, basePath);\n    }\n    if (!basePath) {\n        return ng_redux_1.NgRedux.instance;\n    }\n    var store = getInstanceStore(decoratedInstance);\n    if (!store) {\n        setInstanceStore(decoratedInstance, ng_redux_1.NgRedux.instance.configureSubStore(basePath, options.localReducer));\n    }\n    return getInstanceStore(decoratedInstance);\n};\n/**\n * Creates an Observable from the given selection parameters,\n * rooted at decoratedInstance's store, and caches it on the\n * instance for future use.\n * @hidden\n */\nexports.getInstanceSelection = function (decoratedInstance, key, selector, transformer, comparator) {\n    var store = exports.getBaseStore(decoratedInstance);\n    if (store) {\n        var selections = getInstanceSelectionMap(decoratedInstance);\n        selections[key] =\n            selections[key] ||\n                (!transformer\n                    ? store.select(selector, comparator)\n                    : store\n                        .select(selector)\n                        .pipe(function (obs$) { return transformer(obs$, decoratedInstance); }, operators_1.distinctUntilChanged(comparator)));\n        return selections[key];\n    }\n    return undefined;\n};\n//# sourceMappingURL=helpers.js.map",null]}